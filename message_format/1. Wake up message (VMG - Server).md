# 1. Wake up message (VMG -> Server)

**Spec:** WakeUpLite / v1 (prototype)

- Format: JSON (flat)
- Transport: any (TLS recommended; for prototype may be plain)

## Fields (minimal)
- `msg_id` *(string, required)* — unique message ID (e.g., `"MSG_0001"`)
- `proto_ver` *(string, required)* — protocol version (e.g., `"1.0"`)
- `ts` *(int64, required)* — send time (epoch ms UTC)
- `boot_id` *(string, required)* — boot session ID (e.g., `"BOOT_0123"`)
- `boot_seq` *(uint, required)* — monotonically increasing boot counter (stored in NVRAM/flash)
- `uptime_ms` *(uint, required)* — milliseconds since current boot
- `vehicle_id` *(string, required)* — e.g., `"VEH_001"`
- `gateway_id` *(string, required)* — e.g., `"CCU_001"`
- `client_cert_thumbprint` *(string, required)* — mTLS certificate thumbprint (e.g., `"TH_001"`)

## Minimal example
```json
{
  "msg_id": "MSG_0001",
  "proto_ver": "1.0",
  "ts": 1761351123000,
  "boot_id": "BOOT_0123",
  "boot_seq": 7,
  "uptime_ms": 4215,
  "vehicle_id": "VEH_001",
  "gateway_id": "CCU_001",
  "client_cert_thumbprint": "TH_001"
}
```


## Validation & rules (concise)
- `boot_seq` must be **greater** than the previous stored value.
- Duplicate `boot_id` ⇒ treat as **idempotent** (ignore duplicates).
- `ts` is **Unix epoch ms (UTC)**. If absent (strict minimal), server may rely on receive time.

## Server-side boot_seq processing logic
The `boot_seq` serves four critical purposes for server-side validation:

### 1. **Reboot vs. Retransmission Detection**
- **Same `boot_id` + same `boot_seq`** → Retransmission (treat as idempotent, ignore duplicates)
- **Different `boot_id` + increased `boot_seq`** → Actual reboot (process normally)

### 2. **Boot Loop Detection**
- **Short `uptime_ms` + consecutive `boot_seq` increases** → Suspect boot loop
- **Server action**: Apply safety mode/throttling, investigate root cause

### 3. **Anti-rollback/Replay Protection**
- **`boot_seq` < last stored value** → Suspect rollback/replay attack
- **Possible causes**: Configuration corruption, image downgrade, malicious replay
- **Server action**: Reject message, trigger security alert

### 4. **Boot Sequence Validation**
- **Expected**: `boot_seq` should always increase (monotonic)
- **Server stores**: Last valid `boot_seq` per `vehicle_id`/`gateway_id`
- **Validation**: `current_boot_seq > stored_boot_seq`

## Transport Security Profile (MQTT-TLS-CCU-v1)
**Mandatory MQTT over TLS configuration for VMG ↔ Server communication:**

### **MQTT Protocol Settings**
- **Protocol Version**: MQTT 5.0 (preferred) / MQTT 3.1.1 (fallback)
- **Transport**: MQTT over TLS 1.3 (port 8883)
- **Client ID**: `{vehicle_id}_{gateway_id}` (e.g., `VEH_001_CCU_001`)
- **Clean Session**: `true` (stateless connection)
- **Keep-Alive**: 60 seconds (MQTT ping interval)

### **Key Exchange & Authentication**
- **Key Exchange**: ML-KEM 768 (post-quantum cryptography)
- **Certificate Authentication**: ECDSA with P-256 curve (cellular-optimized)
- **Certificate Chain**: Root CA → Intermediate CA → VMG Certificate
- **Client Certificate**: Required (mTLS) - thumbprint in `client_cert_thumbprint` field

### **Cipher Suites (MQTT-Optimized)**
1. `TLS_AES_128_GCM_SHA256` (AES-128-GCM + SHA-256) - **Primary**
2. `TLS_AES_256_GCM_SHA384` (AES-256-GCM + SHA-384) - **Fallback**

### **MQTT Connection Parameters**
- **Connect Timeout**: 30 seconds
- **Read/Write Timeout**: 120 seconds
- **Reconnect Interval**: 5-30 seconds (exponential backoff)
- **Max Reconnect Attempts**: 10

### **MQTT Topic Structure**
- **Base Topic**: `/ota/{vehicle_id}/{gateway_id}`
- **Wake-up Topic**: `/ota/{vehicle_id}/{gateway_id}/wakeup`
- **QoS Level**: 1 (at least once delivery)
- **Retain Flag**: `false` (no message persistence)

### **Security Considerations**
- **ML-KEM 768**: Post-quantum resistance for long-term security (handshake overhead acceptable)
- **ECC P-256**: Optimized for cellular bandwidth and certificate operations
- **Perfect Forward Secrecy**: Enabled via TLS 1.3 ephemeral keys
- **Certificate Validation**: Strict hostname verification required
- **Message Integrity**: TLS 1.3 provides end-to-end encryption

## Notes
- Keep IDs human-readable for the project: `gateway_id = CCU_###`, `vehicle_id = VEH_###`.
- All TLS parameters are enforced at transport layer; not configurable via message payload.

